https://zhidao.baidu.com/question/174162164.html
http://blog.51cto.com/essun/1379932
https://www.cnblogs.com/tangyuu/p/6396644.html
https://segmentfault.com/a/1190000006689795
http://www.cnblogs.com/vajoy/p/5341664.html
https://www.cnblogs.com/chenqf/p/6386163.html
https://www.cnblogs.com/shangxiaofei/p/6214560.html
http://caibaojian.com/server-cache.html


 response.setHeader("Cache-Control", "no-cache");
        //response.setHeader("Cache-Control", "no-cache");
        //response.setHeader("Expires", new Date(System.currentTimeMillis() + 60000).toGMTString());
        response.setHeader("If-Modified-Since", (new Date()).toGMTString());
        response.setHeader("Pragma", "");

HTTP Header
1. HTTP报文结构
用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。
HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。

HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。

闲篇：\r是回车符,\n是换行符
计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。 
于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。 
这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。 后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。Unix 系统里，每行结尾只有“<换行>”，即“\n”；Windows系统里面，每行结尾是“<回车><换行>”，即“ \r\n”；Mac系统里，每行结尾是“<回车>”。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。

HTTP请求报文


HTTP响应报文

2. HTTP首部
HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分隔。例如，在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的 对象类型。
Content-Type: text/html

HTTP首部字段类型
通用首部字段（General Header Fields）
请求报文和响应报文两方都会使用的首部。

请求首部字段（Request Header Fields）
从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。

响应首部字段（Response Header Fields）
从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。

实体首部字段（Entity Header Fields）
针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。

3. HTTP缓存机制的介绍（为了学习相关字段）
(1) 缓存规则
静态资源默认会使用缓存
Ajax get请求，浏览器可以使用缓存(当然还要看服务器的Cache-Control/Expires/Last-Modified/ETag头的设置)。
Ajax post请求，浏览器都不会缓存。
Https的请求，浏览器不会缓存(绝大数情况如此，但是也有例外，据说FF浏览器是例外)。

4. 通用首部字段(此处基本上以ajax的形式去测试)。

(1) Pragma (html 1.0)
Pragma 是HTTP/1.1之前版本的历史遗留字段，仅作为与HTTP/1.0的向后兼容而定义。当该字段值为“no-cache”的时候（事实上现在RFC中也仅标明该可选值），会知会客户端不要对该资源读缓存，即每次都得向服务器发一次请求才行。

先给大家看一下在没有对客户端和服务端进行设置的情况下：服务端和请求段的header设置。

服务端存在Cache-control(http 1.1中对于缓存控制的header), pragma的header，客户端则没有。
cache-control: no-cache, no-store, max-age=0, must-revalidate （这里的每个值的含义先不多说，因为后面还要学习cache-control，只说一下no-store为不缓存相应的任何内容）
pragma: no-cache 也是不缓存请求。

为什么先说这个首部字段呢，因为http 1.0的这个字段很有意思，会对cache-control的控制产生影响。
Pragma的优先级是高于Cache-Control 的。也就是说就算我这个地方对于cache-control进行了可缓存的设置，只要含有pragma: no-cache的情况下，还是没作用。测试一下：

如图现在我设置了Cache=Control: mxx-age=640800 表示当服务器返回的响应中包含 max-age（640800表示一周）指令时，缓存服务器将不对资源
的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。 但是整个结构还是没有从缓存中拿，因为现在还是存在Pragma：no-cache，优先级高，也是对现在的请求结果不进行缓存的主要原因。

所以为了验证Pragram的作用，我在server设置如下，设置Pragma的值为空。
response.setHeader("Cache-Control", "max-age=604800");
response.setHeader("Pragma", "");

然后我们再看一下下面的请求结果，如图可以看到现在ajax get请求的结果是从缓存中拿到的。

刚才说的是服务端，那么现在在服务段支持缓存的情况下，我们再去client设置pragma: no-cache的话，整个请求又要去访问服务端取新的数据。从这里也看到，请求的是否缓存不仅依赖于服务端，也依赖于客户端。

为什么先说这个，因为接下来学习Cache-control，如果不先将Pragma的影响去掉，着实会影响一大片。


(2) Cache-Control
在下列的指令中有些指令是客户端和服务端都可以使用的，所以在这种指令的讲解过程中，会将两边的使用都去学习。

a. public (仅使用服务端)
表示该响应可以被任何中间人（比如中间代理、CDN等）缓存。若指定了"public"，则一些通常不被中间人缓存的页面（因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定影响状态码的页面），将会被其缓存。
Cache-Control: public

但是如果只使用这个指令的话，客户端还是不能够使用缓存，因为还没有启用缓存机制。所以我使用下面的方式启用缓存，并且设置缓存的使用者为所有人。
response.setHeader("Cache-Control", "public, max-age=604800");
response.setHeader("Pragma", "");

b. private (仅使用服务端)
当指定 private 指令后，响应只以特定的用户作为对象，这与 public指令的行为相反。
而 "private" 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。
Cache-Control: private

c. no-cache (服务端，客户端)

d. no-store （服务端，客户端）
当使用no-store指令时，暗示请求（和对应的响应）或响应中包含机密信息。no-store是真正的不进行缓存。
Cache-Control: no-store

e. max-age (服务端，客户端)
先介绍几个日期，

如图，当前的设置为服务端允许缓存，并且max-age为10s，然后看到第二个红色框的date。那么现在我们的缓存机制是什么呢？
那就是，客户端在一次访问请求的时候，会从缓存服服务器或者浏览器私有服务器去到当前的返回值，然后通过date + 10s与当前的时间进行对比，如果当前时间没有超过date + 10，那么当前的缓存还会被继续使用，而且不会向源服务器验证，反之则会发送全新的请求。

服务端：
当服务器返回的响应中包含max-age指令时，缓存服务器将不对资源的有效性再作确认，而max-age数值代表资源保存为缓存的最长时。具体的例子就是前面的例子。

客户端
我在客户端测试的时候发现max-age有值(不包含0)的时候没有作用，因为服务端的缓存控制着什么时候缓存服务端请求，但是如果是0的话，那么请求会发送到服务端请求。

* 应用 HTTP/1.1版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理max-age指令，而忽略掉Expires首部字段。而HTTP/1.0 版本的缓存服务器的情况却相反，max-age指令会被忽略掉。