https://zhidao.baidu.com/question/174162164.html
http://blog.51cto.com/essun/1379932
https://www.cnblogs.com/tangyuu/p/6396644.html
https://segmentfault.com/a/1190000006689795
http://www.cnblogs.com/vajoy/p/5341664.html
https://www.cnblogs.com/chenqf/p/6386163.html
https://www.cnblogs.com/shangxiaofei/p/6214560.html
http://caibaojian.com/server-cache.html


 response.setHeader("Cache-Control", "no-cache");
        //response.setHeader("Cache-Control", "no-cache");
        //response.setHeader("Expires", new Date(System.currentTimeMillis() + 60000).toGMTString());
        response.setHeader("If-Modified-Since", (new Date()).toGMTString());
        response.setHeader("Pragma", "");

HTTP Header
1. HTTP报文结构
用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。
HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。

HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。

闲篇：\r是回车符,\n是换行符
计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。 
于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。 
这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。 后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。Unix 系统里，每行结尾只有“<换行>”，即“\n”；Windows系统里面，每行结尾是“<回车><换行>”，即“ \r\n”；Mac系统里，每行结尾是“<回车>”。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。

HTTP请求报文


HTTP响应报文

2. HTTP首部
HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分隔。例如，在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的 对象类型。
Content-Type: text/html

HTTP首部字段类型
通用首部字段（General Header Fields）
请求报文和响应报文两方都会使用的首部。

请求首部字段（Request Header Fields）
从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。

响应首部字段（Response Header Fields）
从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。

实体首部字段（Entity Header Fields）
针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。

3. HTTP缓存机制的介绍（为了学习相关字段）
(1) 缓存规则
静态资源默认会使用缓存
Ajax get请求，浏览器可以使用缓存(当然还要看服务器的Cache-Control/Expires/Last-Modified/ETag头的设置)。
Ajax post请求，浏览器都不会缓存。
Https的请求，浏览器不会缓存(绝大数情况如此，但是也有例外，据说FF浏览器是例外)。

4. 通用首部字段(此处基本上以ajax的形式去测试)。

(1) Pragma (html 1.0)
Pragma 是HTTP/1.1之前版本的历史遗留字段，仅作为与HTTP/1.0的向后兼容而定义。当该字段值为“no-cache”的时候（事实上现在RFC中也仅标明该可选值），会知会客户端不要对该资源读缓存，即每次都得向服务器发一次请求才行。

先给大家看一下在没有对客户端和服务端进行设置的情况下：服务端和请求段的header设置。

服务端存在Cache-control(http 1.1中对于缓存控制的header), pragma的header，客户端则没有。
cache-control: no-cache, no-store, max-age=0, must-revalidate （这里的每个值的含义先不多说，因为后面还要学习cache-control，只说一下no-store为不缓存相应的任何内容）
pragma: no-cache 也是不缓存请求。

为什么先说这个首部字段呢，因为http 1.0的这个字段很有意思，会对cache-control的控制产生影响。
Pragma的优先级是高于Cache-Control 的。也就是说就算我这个地方对于cache-control进行了可缓存的设置，只要含有pragma: no-cache的情况下，还是没作用。测试一下：

如图现在我设置了Cache=Control: mxx-age=640800 表示当服务器返回的响应中包含 max-age（640800表示一周）指令时，缓存服务器将不对资源
的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。 但是整个结构还是没有从缓存中拿，因为现在还是存在Pragma：no-cache，优先级高，也是对现在的请求结果不进行缓存的主要原因。

所以为了验证Pragram的作用，我在server设置如下，设置Pragma的值为空。
response.setHeader("Cache-Control", "max-age=604800");
response.setHeader("Pragma", "");

然后我们再看一下下面的请求结果，如图可以看到现在ajax get请求的结果是从缓存中拿到的。

刚才说的是服务端，那么现在在服务段支持缓存的情况下，我们再去client设置pragma: no-cache的话，整个请求又要去访问服务端取新的数据。从这里也看到，请求的是否缓存不仅依赖于服务端，也依赖于客户端。

为什么先说这个，因为接下来学习Cache-control，如果不先将Pragma的影响去掉，着实会影响一大片。


(2) Cache-Control
在下列的指令中有些指令是客户端和服务端都可以使用的，所以在这种指令的讲解过程中，会将两边的使用都去学习。

a. public (仅使用服务端)
表示该响应可以被任何中间人（比如中间代理、CDN等）缓存。若指定了"public"，则一些通常不被中间人缓存的页面（因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定影响状态码的页面），将会被其缓存。
Cache-Control: public

但是如果只使用这个指令的话，客户端还是不能够使用缓存，因为还没有启用缓存机制。所以我使用下面的方式启用缓存，并且设置缓存的使用者为所有人。
response.setHeader("Cache-Control", "public, max-age=604800");
response.setHeader("Pragma", "");

b. private (仅使用服务端)
当指定 private 指令后，响应只以特定的用户作为对象，这与 public指令的行为相反。
而 "private" 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。
Cache-Control: private

c. no-cache (服务端，客户端)

d. no-store （服务端，客户端）
当使用no-store指令时，暗示请求（和对应的响应）或响应中包含机密信息。no-store是真正的不进行缓存。
Cache-Control: no-store

e. max-age (服务端，客户端)
先介绍几个日期，

如图，当前的设置为服务端允许缓存，并且max-age为10s，然后看到第二个红色框的date。那么现在我们的缓存机制是什么呢？
那就是，客户端在一次访问请求的时候，会从缓存服服务器或者浏览器私有服务器去到当前的返回值，然后通过date + 10s与当前的时间进行对比，如果当前时间没有超过date + 10，那么当前的缓存还会被继续使用，而且不会向源服务器验证，反之则会发送全新的请求。

服务端：
当服务器返回的响应中包含max-age指令时，缓存服务器将不对资源的有效性再作确认，而max-age数值代表资源保存为缓存的最长时。具体的例子就是前面的例子。

客户端
我在客户端测试的时候发现max-age有值(不包含0)的时候没有作用，因为服务端的缓存控制着什么时候缓存服务端请求，但是如果是0的话，那么请求会发送到服务端请求。

* 应用 HTTP/1.1版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理max-age指令，而忽略掉Expires首部字段。而HTTP/1.0 版本的缓存服务器的情况却相反，max-age指令会被忽略掉。

f. min-refresh（客户端）
图解http的解释： min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。比如， 当指定 min-fresh 为 60 秒后， 过了 60 秒的资源都无法作为响应返回了。
HTTP权威指南中的解释：至少<s>内文档保持新鲜。

我在这里的理解是：在指定的时间内保持新鲜。那么这个时间是什么呢？类似于max-age，再第一次访问原服务器返回的date时间开始就算缓存时间的新鲜度。现在我们假如min-refresh < max-age。那么这个时间内缓存文档是新鲜的。如果min-refresh > max-age，请求的时候，缓存服务器已经从新到服务器取回新的数据或者更新首部文档信息（304）。那么返回的还是保存新鲜度的文档。那么这个min-refresh好像没有任何的效果，感觉它的规则是其他缓存规则的子集。而且我在测试的时候没有发现有什么不同。
demo: （服务端）max-age = 20, （客户顿）min-refresh = 10, 在10s中以内缓存直接返回200(from disk cache)， 10s ~ 20s 缓存还是直接返回200(from disk cache)。
对于这个的应用，真是没有发现它的精华是什么？如果有知道的，可以说一下，最好说一下测试的步骤。

g. max-stale（客户端）
如果指令未指定参数值， 那么无论经过多久， 客户端都会接收响应；如果指令中指定了具体数值， 那么即使过期， 只要仍处于 max-stale指定的时间内， 仍旧会被客户端接收。

同样的测试没有成功，文档如果设置了过去时间，那么缓存文档过期，原服务器就会重新获取资源或者服务器在验证文档是否有更新。那么max-stale就没有任何效果，设置不设置，缓存的规则都没有任何变化。

f. only-if-cached
使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资
源的情况下才会要求其返回。 换言之， 该指令要求缓存服务器不重新
加载响应， 也不会再次确认资源有效性。 若发生请求缓存服务器的本
地缓存无响应， 则返回状态码 504 Gateway Timeout。

g. must-revalidate 
使用 must-revalidate 指令， 代理会向源服务器再次验证即将返回的响
应缓存目前是否仍然有效。
若代理无法连通源服务器再次获取有效资源的话， 缓存必须给客户端
一条 504（Gateway Timeout） 状态码。
另外， 使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已
经在首部使用了 max-stale， 也不会再有效果） 。

h. proxy-revalidate
Cache-Control: proxy-revalidate
proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指
令的请求返回响应之前， 必须再次验证缓存的有效性。

i. no-transform
Cache-Control: no-transform
使用 no-transform 指令规定无论是在请求还是响应中， 缓存都不能改
变实体主体的媒体类型。
这样做可防止缓存或代理压缩图片等类似操作。

(3) Connection
Connection 首部字段具备如下两个作用。
控制不再转发给代理的首部字段(作用与中间体)

在客户端发送请求和服务器返回响应内， 使用 Connection 首部字
段， 可控制不再转发给代理的首部字段（即 Hop-by-hop 首
部） 。



管理持久连接

提高HTTP的链接性能
将管理持久链接之前，先看集中可以提高HTTP的链接性能的方法

并行连接
通过多条TCP连接发起的并发HTTP请求，

持久链接
重用TCP链接，已消除链接及关闭时延。

管道化链接
通过共享的TCP链接发起并发的HTTP请求（上面两种方式合体）。

复用的链接（试验阶段）
交替传送请求和响应报文

Keep-Alive
HTTP 1.0 keep-alive实现客户端通过包含Connection: keep-alive首部请求将一条链接保持在打开状态。

Connection: Keep-Alive
Keep-Alive: max=5, timeout=120 

Max: 估计服务器还希望为多少个事物保持此链接的活跃状态。这并不是一个承诺值。
timeout： 估计了服务器希望将连接保持在活跃状态的时间，这并不是一个承诺值。

HTTP 1.1 持久链接
HTTP 1.1没有对keep-alive有具体的说明，用一种名为持久链接的改进型设计取代了它。持久链接的目的与keep-alived的目的相同，但工作机制更优一些。

HTTP 1.1持久链接默认情况下是激活的。除非说明不适用持久链接。
Connection: close

(4) Date
首部字段 Date 表明创建 HTTP 报文的日期和时间。这个事前我们也曾提及到，这个表明生成当前文档的时间，也是缓存的新鲜度开始时间（表面上的）。
首部字段 Date 表明创建 HTTP 报文的日期和时间。

(5) Trailer
首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。 该首部字段可应用在 HTTP/1.1 版本分块传输编码时。

f
以上用例中， 指定首部字段 Trailer 的值为 Expires， 在报文主体之后（分块长度 0 之后） 出现了首部字段 Expires。