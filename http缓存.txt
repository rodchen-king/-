服务器再验证
仅仅是缓存文档过期并不意味着它和原始服务器上目前最新的文档有实际的区别，只是说当前需要将副本和服务器上的文档进行核对，这种情况被称为“服务器在验证”，说明缓存需要询问原始服务器文档是否发生了变化。

如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在就文档的位置上，然后将文档发送给客户端。
如果再验证显示内容没有发生变化，缓存会获取新的首部，包括一个新的过期日期，并且对缓存中的首部进行更新就行了。

用条件方法进行在验证
对于服务器在验证，HTTP定义了5个条件请求首部，后面我们都会学习，先来看IF-Modified-Since和If-None-Match。

If-Modified-Since:Date再验证
这里先说一下和last-modified的合作使用，last-modified是作用在响应首部的。先看案例：
首先服务器设置
response.setHeader("Cache-Control", "max-age=30");  //表示从最新一次服务端返回文档到当前缓存文档过期的时长为30s
response.setHeader("Last-Modified", "Wed, 19 Apr 2018 14:26:37 GMT"); //服务端最新一次修改的时间。

如图有五条请求：
第一条请求为第一次访问，所以返回为200，此时浏览器私有缓存缓存当前副本。
第二/三条数据为在max-age=30没有过期的时间段请求的，可以看到红色框内的size为 from disk cache，而且所用时间非常短。
第四条数据此时已经超过了maxa-age=30，所以此时缓存未命中，需要服务器在验证。这里贴出来具体的request和resposne。而且请看绿色框服size没有第一条数据那么大，而且花费时间也较短。这里也表明当前发生的请求是一个简单的条件请求，只是为了验证缓存是否是最新的。

如图可以看到，此时客户端自动带上If-Modified-Since：Date(与last-modified一样)。

第五条数据，请看黑色框中的时间是我修改到了后面一天，有这样当下一次服务器再验证的时候，就会发现当前的文档已经修改了，所以这一条请求也是完全的请求文档的请求。

看了这个例子是不是感觉了解了当前的运作，max-age是用于新鲜度检测的，而last-modified是用于服务器再验证的。IF-Modified-Since首部和Last-Modified服务器响应首部的合作方式：当缓存要对以缓存文档进行再验证时，请求中（上面例子中的第四条）就会自动包含一个If-Modified-Slice首部，日期值为最后修改以缓存副本的日期，也就是last-modified。如果验证中发现last-modified的时间改了，自然会返回全新的文档，如果没有修改，则只返回更新缓存的新鲜度，也就是date，以为重置了date，那么max-age就会重新开始了。

IF-None-Match实体标签再验证
这个例子其实和上面的了类似。因为有些情况下仅仅使用最后修改日期进行验证是不够的。
*有些文档可能会被周期性地重写，但实际包含的数据常常是一样的，尽管内容没有变化，但是修改日期发生了变化。
*有些页面无法判定其页面的最后修改日期。
为了解决这些问题，HTTP允许用户对被称为实体标签（ETag）的“版本标识符”进行比较。实体标签附加到文档上的任意标签（引用字符串：这里的引用字符串是中文版出现的，但是我想可能是翻译出错了，原文是quoted strings，意思应该是引号包含的字符串），这个字符串可能包含了文档的序列号或版本号，或者是文档内容的校验。每当发布者需要更新文档，可以修改文档的尸体标签来说明新的版本产生。然后客户端通过IF-None-Match条件首部来GET文档的新副本。

测试：服务端设置：Etag
response.setHeader("Cache-Control", "max-age=30");
response.setHeader("Etag", "\"v2.0\""); //这样的方式才可以起到作用，这也是为什么我说上面引用字符串翻译的出错了。

当我们在服务端设置Etag，当前客户端文档过期之后进行服务再验证的时候，请求会自动带上If-None-Match。
* Etag：W/"v1.0" 表示弱验证器。这里只是了解有这样的概念。没有W的是强验证器。


(9) 控制缓存的能力